/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: SDAquarium, rhs: SDAquarium) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name)
}

extension SDAquarium : CustomStringConvertible {

  public var description : String {
    var desc = "SDAquarium("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension SDAquarium : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(name)
  }

}

extension SDAquarium : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, ]
  }

  public static var structName: String { return "SDAquarium" }

  public static func read(from proto: TProtocol) throws -> SDAquarium {
    _ = try proto.readStructBegin()
    var id: String!
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")

    return SDAquarium(id: id, name: name)
  }

}



public func ==(lhs: SDPoint, rhs: SDPoint) -> Bool {
  return
    (lhs.t_ms == rhs.t_ms) &&
    (lhs.v == rhs.v)
}

extension SDPoint : CustomStringConvertible {

  public var description : String {
    var desc = "SDPoint("
    desc += "t_ms=\(String(describing: self.t_ms)), "
    desc += "v=\(String(describing: self.v))"
    return desc
  }

}

extension SDPoint : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(t_ms)
    hasher.combine(v)
  }

}

extension SDPoint : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["t_ms": 1, "v": 2, ]
  }

  public static var structName: String { return "SDPoint" }

  public static func read(from proto: TProtocol) throws -> SDPoint {
    _ = try proto.readStructBegin()
    var t_ms: TimestampMs!
    var v: Double!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             t_ms = try TimestampMs.read(from: proto)
        case (2, .double):           v = try Double.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(t_ms, named: "t_ms")
    try proto.validateValue(v, named: "v")

    return SDPoint(t_ms: t_ms, v: v)
  }

}



public func ==(lhs: SDSeries, rhs: SDSeries) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name) &&
    (lhs.color == rhs.color) &&
    (lhs.points == rhs.points)
}

extension SDSeries : CustomStringConvertible {

  public var description : String {
    var desc = "SDSeries("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "color=\(String(describing: self.color)), "
    desc += "points=\(String(describing: self.points))"
    return desc
  }

}

extension SDSeries : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(name)
    hasher.combine(color)
    hasher.combine(points)
  }

}

extension SDSeries : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, "color": 3, "points": 4, ]
  }

  public static var structName: String { return "SDSeries" }

  public static func read(from proto: TProtocol) throws -> SDSeries {
    _ = try proto.readStructBegin()
    var id: String!
    var name: String!
    var color: String?
    var points: TList<SDPoint>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .string):           color = try String.read(from: proto)
        case (4, .list):            points = try TList<SDPoint>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(points, named: "points")

    return SDSeries(id: id, name: name, color: color, points: points)
  }

}



public func ==(lhs: SDChart, rhs: SDChart) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.title == rhs.title) &&
    (lhs.unit == rhs.unit) &&
    (lhs.kind == rhs.kind) &&
    (lhs.yMin == rhs.yMin) &&
    (lhs.yMax == rhs.yMax) &&
    (lhs.fractionDigits == rhs.fractionDigits) &&
    (lhs.series == rhs.series)
}

extension SDChart : CustomStringConvertible {

  public var description : String {
    var desc = "SDChart("
    desc += "id=\(String(describing: self.id)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "unit=\(String(describing: self.unit)), "
    desc += "kind=\(String(describing: self.kind)), "
    desc += "yMin=\(String(describing: self.yMin)), "
    desc += "yMax=\(String(describing: self.yMax)), "
    desc += "fractionDigits=\(String(describing: self.fractionDigits)), "
    desc += "series=\(String(describing: self.series))"
    return desc
  }

}

extension SDChart : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(title)
    hasher.combine(unit)
    hasher.combine(kind)
    hasher.combine(yMin)
    hasher.combine(yMax)
    hasher.combine(fractionDigits)
    hasher.combine(series)
  }

}

extension SDChart : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "title": 2, "unit": 3, "kind": 4, "yMin": 5, "yMax": 6, "fractionDigits": 7, "series": 8, ]
  }

  public static var structName: String { return "SDChart" }

  public static func read(from proto: TProtocol) throws -> SDChart {
    _ = try proto.readStructBegin()
    var id: String!
    var title: String!
    var unit: String?
    var kind: ChartKind!
    var yMin: Double?
    var yMax: Double?
    var fractionDigits: Int32?
    var series: TList<SDSeries>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           title = try String.read(from: proto)
        case (3, .string):           unit = try String.read(from: proto)
        case (4, .i32):             kind = try ChartKind.read(from: proto)
        case (5, .double):           yMin = try Double.read(from: proto)
        case (6, .double):           yMax = try Double.read(from: proto)
        case (7, .i32):             fractionDigits = try Int32.read(from: proto)
        case (8, .list):            series = try TList<SDSeries>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(kind, named: "kind")
    try proto.validateValue(series, named: "series")

    return SDChart(id: id, title: title, unit: unit, kind: kind, yMin: yMin, yMax: yMax, fractionDigits: fractionDigits, series: series)
  }

}



public func ==(lhs: SDTile, rhs: SDTile) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.title == rhs.title) &&
    (lhs.unit == rhs.unit) &&
    (lhs.value == rhs.value) &&
    (lhs.precision == rhs.precision)
}

extension SDTile : CustomStringConvertible {

  public var description : String {
    var desc = "SDTile("
    desc += "id=\(String(describing: self.id)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "unit=\(String(describing: self.unit)), "
    desc += "value=\(String(describing: self.value)), "
    desc += "precision=\(String(describing: self.precision))"
    return desc
  }

}

extension SDTile : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(title)
    hasher.combine(unit)
    hasher.combine(value)
    hasher.combine(precision)
  }

}

extension SDTile : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "title": 2, "unit": 3, "value": 4, "precision": 5, ]
  }

  public static var structName: String { return "SDTile" }

  public static func read(from proto: TProtocol) throws -> SDTile {
    _ = try proto.readStructBegin()
    var id: String!
    var title: String!
    var unit: String?
    var value: Double?
    var precision: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           title = try String.read(from: proto)
        case (3, .string):           unit = try String.read(from: proto)
        case (4, .double):           value = try Double.read(from: proto)
        case (5, .i32):             precision = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(title, named: "title")

    return SDTile(id: id, title: title, unit: unit, value: value, precision: precision)
  }

}



public func ==(lhs: SDOverlay, rhs: SDOverlay) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name) &&
    (lhs.color == rhs.color) &&
    (lhs.points == rhs.points)
}

extension SDOverlay : CustomStringConvertible {

  public var description : String {
    var desc = "SDOverlay("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "color=\(String(describing: self.color)), "
    desc += "points=\(String(describing: self.points))"
    return desc
  }

}

extension SDOverlay : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(name)
    hasher.combine(color)
    hasher.combine(points)
  }

}

extension SDOverlay : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, "color": 3, "points": 4, ]
  }

  public static var structName: String { return "SDOverlay" }

  public static func read(from proto: TProtocol) throws -> SDOverlay {
    _ = try proto.readStructBegin()
    var id: String!
    var name: String!
    var color: String?
    var points: TList<SDPoint>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .string):           color = try String.read(from: proto)
        case (4, .list):            points = try TList<SDPoint>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(points, named: "points")

    return SDOverlay(id: id, name: name, color: color, points: points)
  }

}



public func ==(lhs: SDPage, rhs: SDPage) -> Bool {
  return
    (lhs.title == rhs.title) &&
    (lhs.tiles == rhs.tiles) &&
    (lhs.charts == rhs.charts) &&
    (lhs.overlays == rhs.overlays)
}

extension SDPage : CustomStringConvertible {

  public var description : String {
    var desc = "SDPage("
    desc += "title=\(String(describing: self.title)), "
    desc += "tiles=\(String(describing: self.tiles)), "
    desc += "charts=\(String(describing: self.charts)), "
    desc += "overlays=\(String(describing: self.overlays))"
    return desc
  }

}

extension SDPage : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(title)
    hasher.combine(tiles)
    hasher.combine(charts)
    hasher.combine(overlays)
  }

}

extension SDPage : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["title": 1, "tiles": 2, "charts": 3, "overlays": 4, ]
  }

  public static var structName: String { return "SDPage" }

  public static func read(from proto: TProtocol) throws -> SDPage {
    _ = try proto.readStructBegin()
    var title: String!
    var tiles: TList<SDTile>!
    var charts: TList<SDChart>!
    var overlays: TList<SDOverlay>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           title = try String.read(from: proto)
        case (2, .list):            tiles = try TList<SDTile>.read(from: proto)
        case (3, .list):            charts = try TList<SDChart>.read(from: proto)
        case (4, .list):            overlays = try TList<SDOverlay>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(title, named: "title")
    try proto.validateValue(tiles, named: "tiles")
    try proto.validateValue(charts, named: "charts")

    return SDPage(title: title, tiles: tiles, charts: charts, overlays: overlays)
  }

}



public func ==(lhs: TileSkeleton, rhs: TileSkeleton) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.title == rhs.title) &&
    (lhs.unit == rhs.unit) &&
    (lhs.precision == rhs.precision)
}

extension TileSkeleton : CustomStringConvertible {

  public var description : String {
    var desc = "TileSkeleton("
    desc += "id=\(String(describing: self.id)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "unit=\(String(describing: self.unit)), "
    desc += "precision=\(String(describing: self.precision))"
    return desc
  }

}

extension TileSkeleton : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(title)
    hasher.combine(unit)
    hasher.combine(precision)
  }

}

extension TileSkeleton : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "title": 2, "unit": 3, "precision": 4, ]
  }

  public static var structName: String { return "TileSkeleton" }

  public static func read(from proto: TProtocol) throws -> TileSkeleton {
    _ = try proto.readStructBegin()
    var id: String!
    var title: String!
    var unit: String?
    var precision: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           title = try String.read(from: proto)
        case (3, .string):           unit = try String.read(from: proto)
        case (4, .i32):             precision = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(title, named: "title")

    return TileSkeleton(id: id, title: title, unit: unit, precision: precision)
  }

}



public func ==(lhs: SeriesSkeleton, rhs: SeriesSkeleton) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name) &&
    (lhs.color == rhs.color)
}

extension SeriesSkeleton : CustomStringConvertible {

  public var description : String {
    var desc = "SeriesSkeleton("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "color=\(String(describing: self.color))"
    return desc
  }

}

extension SeriesSkeleton : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(name)
    hasher.combine(color)
  }

}

extension SeriesSkeleton : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, "color": 3, ]
  }

  public static var structName: String { return "SeriesSkeleton" }

  public static func read(from proto: TProtocol) throws -> SeriesSkeleton {
    _ = try proto.readStructBegin()
    var id: String!
    var name: String!
    var color: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .string):           color = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")

    return SeriesSkeleton(id: id, name: name, color: color)
  }

}



public func ==(lhs: ChartSkeleton, rhs: ChartSkeleton) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.title == rhs.title) &&
    (lhs.unit == rhs.unit) &&
    (lhs.kind == rhs.kind) &&
    (lhs.yMin == rhs.yMin) &&
    (lhs.yMax == rhs.yMax) &&
    (lhs.fractionDigits == rhs.fractionDigits) &&
    (lhs.series == rhs.series)
}

extension ChartSkeleton : CustomStringConvertible {

  public var description : String {
    var desc = "ChartSkeleton("
    desc += "id=\(String(describing: self.id)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "unit=\(String(describing: self.unit)), "
    desc += "kind=\(String(describing: self.kind)), "
    desc += "yMin=\(String(describing: self.yMin)), "
    desc += "yMax=\(String(describing: self.yMax)), "
    desc += "fractionDigits=\(String(describing: self.fractionDigits)), "
    desc += "series=\(String(describing: self.series))"
    return desc
  }

}

extension ChartSkeleton : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(title)
    hasher.combine(unit)
    hasher.combine(kind)
    hasher.combine(yMin)
    hasher.combine(yMax)
    hasher.combine(fractionDigits)
    hasher.combine(series)
  }

}

extension ChartSkeleton : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "title": 2, "unit": 3, "kind": 4, "yMin": 5, "yMax": 6, "fractionDigits": 7, "series": 8, ]
  }

  public static var structName: String { return "ChartSkeleton" }

  public static func read(from proto: TProtocol) throws -> ChartSkeleton {
    _ = try proto.readStructBegin()
    var id: String!
    var title: String!
    var unit: String?
    var kind: ChartKind!
    var yMin: Double?
    var yMax: Double?
    var fractionDigits: Int32?
    var series: TList<SeriesSkeleton>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           title = try String.read(from: proto)
        case (3, .string):           unit = try String.read(from: proto)
        case (4, .i32):             kind = try ChartKind.read(from: proto)
        case (5, .double):           yMin = try Double.read(from: proto)
        case (6, .double):           yMax = try Double.read(from: proto)
        case (7, .i32):             fractionDigits = try Int32.read(from: proto)
        case (8, .list):            series = try TList<SeriesSkeleton>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(kind, named: "kind")
    try proto.validateValue(series, named: "series")

    return ChartSkeleton(id: id, title: title, unit: unit, kind: kind, yMin: yMin, yMax: yMax, fractionDigits: fractionDigits, series: series)
  }

}



public func ==(lhs: DashboardSkeleton, rhs: DashboardSkeleton) -> Bool {
  return
    (lhs.aquariumId == rhs.aquariumId) &&
    (lhs.tiles == rhs.tiles) &&
    (lhs.charts == rhs.charts)
}

extension DashboardSkeleton : CustomStringConvertible {

  public var description : String {
    var desc = "DashboardSkeleton("
    desc += "aquariumId=\(String(describing: self.aquariumId)), "
    desc += "tiles=\(String(describing: self.tiles)), "
    desc += "charts=\(String(describing: self.charts))"
    return desc
  }

}

extension DashboardSkeleton : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(aquariumId)
    hasher.combine(tiles)
    hasher.combine(charts)
  }

}

extension DashboardSkeleton : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["aquariumId": 1, "tiles": 2, "charts": 3, ]
  }

  public static var structName: String { return "DashboardSkeleton" }

  public static func read(from proto: TProtocol) throws -> DashboardSkeleton {
    _ = try proto.readStructBegin()
    var aquariumId: String!
    var tiles: TList<TileSkeleton>!
    var charts: TList<ChartSkeleton>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           aquariumId = try String.read(from: proto)
        case (2, .list):            tiles = try TList<TileSkeleton>.read(from: proto)
        case (3, .list):            charts = try TList<ChartSkeleton>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(aquariumId, named: "aquariumId")
    try proto.validateValue(tiles, named: "tiles")
    try proto.validateValue(charts, named: "charts")

    return DashboardSkeleton(aquariumId: aquariumId, tiles: tiles, charts: charts)
  }

}



public func ==(lhs: TileUpdate, rhs: TileUpdate) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.value == rhs.value)
}

extension TileUpdate : CustomStringConvertible {

  public var description : String {
    var desc = "TileUpdate("
    desc += "id=\(String(describing: self.id)), "
    desc += "value=\(String(describing: self.value))"
    return desc
  }

}

extension TileUpdate : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(value)
  }

}

extension TileUpdate : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "value": 2, ]
  }

  public static var structName: String { return "TileUpdate" }

  public static func read(from proto: TProtocol) throws -> TileUpdate {
    _ = try proto.readStructBegin()
    var id: String!
    var value: Double?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .double):           value = try Double.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")

    return TileUpdate(id: id, value: value)
  }

}



public func ==(lhs: SeriesUpdate, rhs: SeriesUpdate) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.points == rhs.points)
}

extension SeriesUpdate : CustomStringConvertible {

  public var description : String {
    var desc = "SeriesUpdate("
    desc += "id=\(String(describing: self.id)), "
    desc += "points=\(String(describing: self.points))"
    return desc
  }

}

extension SeriesUpdate : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(points)
  }

}

extension SeriesUpdate : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "points": 2, ]
  }

  public static var structName: String { return "SeriesUpdate" }

  public static func read(from proto: TProtocol) throws -> SeriesUpdate {
    _ = try proto.readStructBegin()
    var id: String!
    var points: TList<SDPoint>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .list):            points = try TList<SDPoint>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(points, named: "points")

    return SeriesUpdate(id: id, points: points)
  }

}



public func ==(lhs: ChartUpdate, rhs: ChartUpdate) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.series == rhs.series)
}

extension ChartUpdate : CustomStringConvertible {

  public var description : String {
    var desc = "ChartUpdate("
    desc += "id=\(String(describing: self.id)), "
    desc += "series=\(String(describing: self.series))"
    return desc
  }

}

extension ChartUpdate : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(series)
  }

}

extension ChartUpdate : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "series": 2, ]
  }

  public static var structName: String { return "ChartUpdate" }

  public static func read(from proto: TProtocol) throws -> ChartUpdate {
    _ = try proto.readStructBegin()
    var id: String!
    var series: TList<SeriesUpdate>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .list):            series = try TList<SeriesUpdate>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(series, named: "series")

    return ChartUpdate(id: id, series: series)
  }

}



public func ==(lhs: CompletionEvent, rhs: CompletionEvent) -> Bool {
  return
    (lhs.totalWidgets == rhs.totalWidgets) &&
    (lhs.durationMs == rhs.durationMs)
}

extension CompletionEvent : CustomStringConvertible {

  public var description : String {
    var desc = "CompletionEvent("
    desc += "totalWidgets=\(String(describing: self.totalWidgets)), "
    desc += "durationMs=\(String(describing: self.durationMs))"
    return desc
  }

}

extension CompletionEvent : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(totalWidgets)
    hasher.combine(durationMs)
  }

}

extension CompletionEvent : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["totalWidgets": 1, "durationMs": 2, ]
  }

  public static var structName: String { return "CompletionEvent" }

  public static func read(from proto: TProtocol) throws -> CompletionEvent {
    _ = try proto.readStructBegin()
    var totalWidgets: Int32!
    var durationMs: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             totalWidgets = try Int32.read(from: proto)
        case (2, .i64):             durationMs = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(totalWidgets, named: "totalWidgets")
    try proto.validateValue(durationMs, named: "durationMs")

    return CompletionEvent(totalWidgets: totalWidgets, durationMs: durationMs)
  }

}



public func ==(lhs: StreamMessage, rhs: StreamMessage) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.skeleton == rhs.skeleton) &&
    (lhs.tileUpdate == rhs.tileUpdate) &&
    (lhs.chartUpdate == rhs.chartUpdate) &&
    (lhs.complete == rhs.complete)
}

extension StreamMessage : CustomStringConvertible {

  public var description : String {
    var desc = "StreamMessage("
    desc += "type=\(String(describing: self.type)), "
    desc += "skeleton=\(String(describing: self.skeleton)), "
    desc += "tileUpdate=\(String(describing: self.tileUpdate)), "
    desc += "chartUpdate=\(String(describing: self.chartUpdate)), "
    desc += "complete=\(String(describing: self.complete))"
    return desc
  }

}

extension StreamMessage : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(type)
    hasher.combine(skeleton)
    hasher.combine(tileUpdate)
    hasher.combine(chartUpdate)
    hasher.combine(complete)
  }

}

extension StreamMessage : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["type": 1, "skeleton": 2, "tileUpdate": 3, "chartUpdate": 4, "complete": 5, ]
  }

  public static var structName: String { return "StreamMessage" }

  public static func read(from proto: TProtocol) throws -> StreamMessage {
    _ = try proto.readStructBegin()
    var type: StreamMessageType!
    var skeleton: DashboardSkeleton?
    var tileUpdate: TileUpdate?
    var chartUpdate: ChartUpdate?
    var complete: CompletionEvent?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             type = try StreamMessageType.read(from: proto)
        case (2, .struct):           skeleton = try DashboardSkeleton.read(from: proto)
        case (3, .struct):           tileUpdate = try TileUpdate.read(from: proto)
        case (4, .struct):           chartUpdate = try ChartUpdate.read(from: proto)
        case (5, .struct):           complete = try CompletionEvent.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")

    return StreamMessage(type: type, skeleton: skeleton, tileUpdate: tileUpdate, chartUpdate: chartUpdate, complete: complete)
  }

}



fileprivate final class TelemetryService_Aquariums_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: TelemetryService_Aquariums_args, rhs: TelemetryService_Aquariums_args) -> Bool {
  return true
}

extension TelemetryService_Aquariums_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension TelemetryService_Aquariums_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "TelemetryService_Aquariums_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TelemetryService_Aquariums_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TelemetryService_Aquariums_args()
  }

}



fileprivate final class TelemetryService_Aquariums_result {

  fileprivate var success: TList<SDAquarium>?


  fileprivate init() { }
  fileprivate init(success: TList<SDAquarium>?) {
    self.success = success
  }

}

fileprivate func ==(lhs: TelemetryService_Aquariums_result, rhs: TelemetryService_Aquariums_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension TelemetryService_Aquariums_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension TelemetryService_Aquariums_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "TelemetryService_Aquariums_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TelemetryService_Aquariums_result {
    _ = try proto.readStructBegin()
    var success: TList<SDAquarium>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<SDAquarium>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TelemetryService_Aquariums_result(success: success)
  }

}



fileprivate final class TelemetryService_Dashboard_args {

  fileprivate var aquarium_id: String

  fileprivate var hours: Int32


  fileprivate init(aquarium_id: String, hours: Int32) {
    self.aquarium_id = aquarium_id
    self.hours = hours
  }

}

fileprivate func ==(lhs: TelemetryService_Dashboard_args, rhs: TelemetryService_Dashboard_args) -> Bool {
  return
    (lhs.aquarium_id == rhs.aquarium_id) &&
    (lhs.hours == rhs.hours)
}

extension TelemetryService_Dashboard_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(aquarium_id)
    hasher.combine(hours)
  }

}

extension TelemetryService_Dashboard_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["aquarium_id": 1, "hours": 2, ]
  }

  fileprivate static var structName: String { return "TelemetryService_Dashboard_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TelemetryService_Dashboard_args {
    _ = try proto.readStructBegin()
    var aquarium_id: String!
    var hours: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           aquarium_id = try String.read(from: proto)
        case (2, .i32):             hours = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(aquarium_id, named: "aquarium_id")
    try proto.validateValue(hours, named: "hours")

    return TelemetryService_Dashboard_args(aquarium_id: aquarium_id, hours: hours)
  }

}



fileprivate final class TelemetryService_Dashboard_result {

  fileprivate var success: SDPage?


  fileprivate init() { }
  fileprivate init(success: SDPage?) {
    self.success = success
  }

}

fileprivate func ==(lhs: TelemetryService_Dashboard_result, rhs: TelemetryService_Dashboard_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension TelemetryService_Dashboard_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension TelemetryService_Dashboard_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "TelemetryService_Dashboard_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TelemetryService_Dashboard_result {
    _ = try proto.readStructBegin()
    var success: SDPage?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SDPage.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TelemetryService_Dashboard_result(success: success)
  }

}



extension TelemetryServiceClient : TelemetryService {

  private func send_Aquariums() throws {
    try outProtocol.writeMessageBegin(name: "Aquariums", type: .call, sequenceID: 0)
    let args = TelemetryService_Aquariums_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_Aquariums() throws -> TList<SDAquarium> {
    try inProtocol.readResultMessageBegin() 
    let result = try TelemetryService_Aquariums_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "Aquariums"))
  }

  public func Aquariums() throws -> TList<SDAquarium> {
    try send_Aquariums()
    try outProtocol.transport.flush()
    return try recv_Aquariums()
  }

  private func send_Dashboard(aquarium_id: String, hours: Int32) throws {
    try outProtocol.writeMessageBegin(name: "Dashboard", type: .call, sequenceID: 0)
    let args = TelemetryService_Dashboard_args(aquarium_id: aquarium_id, hours: hours)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_Dashboard() throws -> SDPage {
    try inProtocol.readResultMessageBegin() 
    let result = try TelemetryService_Dashboard_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "Dashboard"))
  }

  public func Dashboard(aquarium_id: String, hours: Int32) throws -> SDPage {
    try send_Dashboard(aquarium_id: aquarium_id, hours: hours)
    try outProtocol.transport.flush()
    return try recv_Dashboard()
  }

}

extension TelemetryServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["Aquariums"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TelemetryService_Aquariums_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TelemetryService_Aquariums_result()
      do {
        result.success = try handler.Aquariums()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "Aquariums", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["Dashboard"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TelemetryService_Dashboard_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TelemetryService_Dashboard_result()
      do {
        result.success = try handler.Dashboard(aquarium_id: args.aquarium_id, hours: args.hours)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "Dashboard", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = TelemetryServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

