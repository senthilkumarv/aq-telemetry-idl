// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChartKind(pub i32);

impl ChartKind {
  pub const LINE: ChartKind = ChartKind(1);
  pub const MULTILINE: ChartKind = ChartKind(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LINE,
    Self::MULTILINE,
  ];
}

impl TSerializable for ChartKind {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChartKind> {
    let enum_value = i_prot.read_i32()?;
    Ok(ChartKind::from(enum_value))
  }
}

impl From<i32> for ChartKind {
  fn from(i: i32) -> Self {
    match i {
      1 => ChartKind::LINE,
      2 => ChartKind::MULTILINE,
      _ => ChartKind(i)
    }
  }
}

impl From<&i32> for ChartKind {
  fn from(i: &i32) -> Self {
    ChartKind::from(*i)
  }
}

impl From<ChartKind> for i32 {
  fn from(e: ChartKind) -> i32 {
    e.0
  }
}

impl From<&ChartKind> for i32 {
  fn from(e: &ChartKind) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StreamMessageType(pub i32);

impl StreamMessageType {
  pub const SKELETON: StreamMessageType = StreamMessageType(1);
  pub const TILE_UPDATE: StreamMessageType = StreamMessageType(2);
  pub const CHART_UPDATE: StreamMessageType = StreamMessageType(3);
  pub const COMPLETE: StreamMessageType = StreamMessageType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SKELETON,
    Self::TILE_UPDATE,
    Self::CHART_UPDATE,
    Self::COMPLETE,
  ];
}

impl TSerializable for StreamMessageType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StreamMessageType> {
    let enum_value = i_prot.read_i32()?;
    Ok(StreamMessageType::from(enum_value))
  }
}

impl From<i32> for StreamMessageType {
  fn from(i: i32) -> Self {
    match i {
      1 => StreamMessageType::SKELETON,
      2 => StreamMessageType::TILE_UPDATE,
      3 => StreamMessageType::CHART_UPDATE,
      4 => StreamMessageType::COMPLETE,
      _ => StreamMessageType(i)
    }
  }
}

impl From<&i32> for StreamMessageType {
  fn from(i: &i32) -> Self {
    StreamMessageType::from(*i)
  }
}

impl From<StreamMessageType> for i32 {
  fn from(e: StreamMessageType) -> i32 {
    e.0
  }
}

impl From<&StreamMessageType> for i32 {
  fn from(e: &StreamMessageType) -> i32 {
    e.0
  }
}

pub type TimestampMs = i64;

//
// SDAquarium
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDAquarium {
  pub id: Option<String>,
  pub name: Option<String>,
}

impl SDAquarium {
  pub fn new<F1, F2>(id: F1, name: F2) -> SDAquarium where F1: Into<Option<String>>, F2: Into<Option<String>> {
    SDAquarium {
      id: id.into(),
      name: name.into(),
    }
  }
}

impl TSerializable for SDAquarium {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDAquarium> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDAquarium {
      id: f_1,
      name: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDAquarium");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SDPoint
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDPoint {
  pub t_ms: Option<TimestampMs>,
  pub v: Option<OrderedFloat<f64>>,
}

impl SDPoint {
  pub fn new<F1, F2>(t_ms: F1, v: F2) -> SDPoint where F1: Into<Option<TimestampMs>>, F2: Into<Option<OrderedFloat<f64>>> {
    SDPoint {
      t_ms: t_ms.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SDPoint {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDPoint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TimestampMs> = Some(0);
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDPoint {
      t_ms: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDPoint");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.t_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("t_ms", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SDSeries
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDSeries {
  pub id: Option<String>,
  pub name: Option<String>,
  pub color: Option<String>,
  pub points: Option<Vec<SDPoint>>,
}

impl SDSeries {
  pub fn new<F1, F2, F3, F4>(id: F1, name: F2, color: F3, points: F4) -> SDSeries where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<SDPoint>>> {
    SDSeries {
      id: id.into(),
      name: name.into(),
      color: color.into(),
      points: points.into(),
    }
  }
}

impl TSerializable for SDSeries {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDSeries> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<SDPoint>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDPoint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = SDPoint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDSeries {
      id: f_1,
      name: f_2,
      color: f_3,
      points: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDSeries");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.color {
      o_prot.write_field_begin(&TFieldIdentifier::new("color", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.points {
      o_prot.write_field_begin(&TFieldIdentifier::new("points", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SDChart
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDChart {
  pub id: Option<String>,
  pub title: Option<String>,
  pub unit: Option<String>,
  pub kind: Option<ChartKind>,
  pub y_min: Option<OrderedFloat<f64>>,
  pub y_max: Option<OrderedFloat<f64>>,
  pub fraction_digits: Option<i32>,
  pub series: Option<Vec<SDSeries>>,
}

impl SDChart {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(id: F1, title: F2, unit: F3, kind: F4, y_min: F5, y_max: F6, fraction_digits: F7, series: F8) -> SDChart where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<ChartKind>>, F5: Into<Option<OrderedFloat<f64>>>, F6: Into<Option<OrderedFloat<f64>>>, F7: Into<Option<i32>>, F8: Into<Option<Vec<SDSeries>>> {
    SDChart {
      id: id.into(),
      title: title.into(),
      unit: unit.into(),
      kind: kind.into(),
      y_min: y_min.into(),
      y_max: y_max.into(),
      fraction_digits: fraction_digits.into(),
      series: series.into(),
    }
  }
}

impl TSerializable for SDChart {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDChart> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<ChartKind> = None;
    let mut f_5: Option<OrderedFloat<f64>> = None;
    let mut f_6: Option<OrderedFloat<f64>> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<Vec<SDSeries>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = ChartKind::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        6 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDSeries> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = SDSeries::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDChart {
      id: f_1,
      title: f_2,
      unit: f_3,
      kind: f_4,
      y_min: f_5,
      y_max: f_6,
      fraction_digits: f_7,
      series: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDChart");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unit {
      o_prot.write_field_begin(&TFieldIdentifier::new("unit", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("yMin", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("yMax", TType::Double, 6))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fraction_digits {
      o_prot.write_field_begin(&TFieldIdentifier::new("fractionDigits", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.series {
      o_prot.write_field_begin(&TFieldIdentifier::new("series", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SDTile
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDTile {
  pub id: Option<String>,
  pub title: Option<String>,
  pub unit: Option<String>,
  pub value: Option<OrderedFloat<f64>>,
  pub precision: Option<i32>,
}

impl SDTile {
  pub fn new<F1, F2, F3, F4, F5>(id: F1, title: F2, unit: F3, value: F4, precision: F5) -> SDTile where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<OrderedFloat<f64>>>, F5: Into<Option<i32>> {
    SDTile {
      id: id.into(),
      title: title.into(),
      unit: unit.into(),
      value: value.into(),
      precision: precision.into(),
    }
  }
}

impl TSerializable for SDTile {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDTile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<OrderedFloat<f64>> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDTile {
      id: f_1,
      title: f_2,
      unit: f_3,
      value: f_4,
      precision: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDTile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unit {
      o_prot.write_field_begin(&TFieldIdentifier::new("unit", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 4))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.precision {
      o_prot.write_field_begin(&TFieldIdentifier::new("precision", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SDOverlay
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDOverlay {
  pub id: Option<String>,
  pub name: Option<String>,
  pub color: Option<String>,
  pub points: Option<Vec<SDPoint>>,
}

impl SDOverlay {
  pub fn new<F1, F2, F3, F4>(id: F1, name: F2, color: F3, points: F4) -> SDOverlay where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<SDPoint>>> {
    SDOverlay {
      id: id.into(),
      name: name.into(),
      color: color.into(),
      points: points.into(),
    }
  }
}

impl TSerializable for SDOverlay {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDOverlay> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<SDPoint>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDPoint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = SDPoint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDOverlay {
      id: f_1,
      name: f_2,
      color: f_3,
      points: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDOverlay");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.color {
      o_prot.write_field_begin(&TFieldIdentifier::new("color", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.points {
      o_prot.write_field_begin(&TFieldIdentifier::new("points", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SDPage
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SDPage {
  pub title: Option<String>,
  pub tiles: Option<Vec<SDTile>>,
  pub charts: Option<Vec<SDChart>>,
  pub overlays: Option<Vec<SDOverlay>>,
}

impl SDPage {
  pub fn new<F1, F2, F3, F4>(title: F1, tiles: F2, charts: F3, overlays: F4) -> SDPage where F1: Into<Option<String>>, F2: Into<Option<Vec<SDTile>>>, F3: Into<Option<Vec<SDChart>>>, F4: Into<Option<Vec<SDOverlay>>> {
    SDPage {
      title: title.into(),
      tiles: tiles.into(),
      charts: charts.into(),
      overlays: overlays.into(),
    }
  }
}

impl TSerializable for SDPage {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SDPage> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<SDTile>> = Some(Vec::new());
    let mut f_3: Option<Vec<SDChart>> = Some(Vec::new());
    let mut f_4: Option<Vec<SDOverlay>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDTile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = SDTile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDChart> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = SDChart::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDOverlay> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = SDOverlay::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SDPage {
      title: f_1,
      tiles: f_2,
      charts: f_3,
      overlays: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SDPage");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tiles {
      o_prot.write_field_begin(&TFieldIdentifier::new("tiles", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.charts {
      o_prot.write_field_begin(&TFieldIdentifier::new("charts", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.overlays {
      o_prot.write_field_begin(&TFieldIdentifier::new("overlays", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TileSkeleton
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TileSkeleton {
  pub id: Option<String>,
  pub title: Option<String>,
  pub unit: Option<String>,
  pub precision: Option<i32>,
}

impl TileSkeleton {
  pub fn new<F1, F2, F3, F4>(id: F1, title: F2, unit: F3, precision: F4) -> TileSkeleton where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>> {
    TileSkeleton {
      id: id.into(),
      title: title.into(),
      unit: unit.into(),
      precision: precision.into(),
    }
  }
}

impl TSerializable for TileSkeleton {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TileSkeleton> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TileSkeleton {
      id: f_1,
      title: f_2,
      unit: f_3,
      precision: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TileSkeleton");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unit {
      o_prot.write_field_begin(&TFieldIdentifier::new("unit", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.precision {
      o_prot.write_field_begin(&TFieldIdentifier::new("precision", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SeriesSkeleton
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SeriesSkeleton {
  pub id: Option<String>,
  pub name: Option<String>,
  pub color: Option<String>,
}

impl SeriesSkeleton {
  pub fn new<F1, F2, F3>(id: F1, name: F2, color: F3) -> SeriesSkeleton where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    SeriesSkeleton {
      id: id.into(),
      name: name.into(),
      color: color.into(),
    }
  }
}

impl TSerializable for SeriesSkeleton {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SeriesSkeleton> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SeriesSkeleton {
      id: f_1,
      name: f_2,
      color: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SeriesSkeleton");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.color {
      o_prot.write_field_begin(&TFieldIdentifier::new("color", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChartSkeleton
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChartSkeleton {
  pub id: Option<String>,
  pub title: Option<String>,
  pub unit: Option<String>,
  pub kind: Option<ChartKind>,
  pub y_min: Option<OrderedFloat<f64>>,
  pub y_max: Option<OrderedFloat<f64>>,
  pub fraction_digits: Option<i32>,
  pub series: Option<Vec<SeriesSkeleton>>,
}

impl ChartSkeleton {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(id: F1, title: F2, unit: F3, kind: F4, y_min: F5, y_max: F6, fraction_digits: F7, series: F8) -> ChartSkeleton where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<ChartKind>>, F5: Into<Option<OrderedFloat<f64>>>, F6: Into<Option<OrderedFloat<f64>>>, F7: Into<Option<i32>>, F8: Into<Option<Vec<SeriesSkeleton>>> {
    ChartSkeleton {
      id: id.into(),
      title: title.into(),
      unit: unit.into(),
      kind: kind.into(),
      y_min: y_min.into(),
      y_max: y_max.into(),
      fraction_digits: fraction_digits.into(),
      series: series.into(),
    }
  }
}

impl TSerializable for ChartSkeleton {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChartSkeleton> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<ChartKind> = None;
    let mut f_5: Option<OrderedFloat<f64>> = None;
    let mut f_6: Option<OrderedFloat<f64>> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<Vec<SeriesSkeleton>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = ChartKind::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        6 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SeriesSkeleton> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = SeriesSkeleton::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChartSkeleton {
      id: f_1,
      title: f_2,
      unit: f_3,
      kind: f_4,
      y_min: f_5,
      y_max: f_6,
      fraction_digits: f_7,
      series: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChartSkeleton");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unit {
      o_prot.write_field_begin(&TFieldIdentifier::new("unit", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("yMin", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("yMax", TType::Double, 6))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fraction_digits {
      o_prot.write_field_begin(&TFieldIdentifier::new("fractionDigits", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.series {
      o_prot.write_field_begin(&TFieldIdentifier::new("series", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DashboardSkeleton
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DashboardSkeleton {
  pub aquarium_id: Option<String>,
  pub tiles: Option<Vec<TileSkeleton>>,
  pub charts: Option<Vec<ChartSkeleton>>,
}

impl DashboardSkeleton {
  pub fn new<F1, F2, F3>(aquarium_id: F1, tiles: F2, charts: F3) -> DashboardSkeleton where F1: Into<Option<String>>, F2: Into<Option<Vec<TileSkeleton>>>, F3: Into<Option<Vec<ChartSkeleton>>> {
    DashboardSkeleton {
      aquarium_id: aquarium_id.into(),
      tiles: tiles.into(),
      charts: charts.into(),
    }
  }
}

impl TSerializable for DashboardSkeleton {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DashboardSkeleton> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<TileSkeleton>> = Some(Vec::new());
    let mut f_3: Option<Vec<ChartSkeleton>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TileSkeleton> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = TileSkeleton::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ChartSkeleton> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = ChartSkeleton::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DashboardSkeleton {
      aquarium_id: f_1,
      tiles: f_2,
      charts: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DashboardSkeleton");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.aquarium_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("aquariumId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tiles {
      o_prot.write_field_begin(&TFieldIdentifier::new("tiles", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.charts {
      o_prot.write_field_begin(&TFieldIdentifier::new("charts", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TileUpdate
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TileUpdate {
  pub id: Option<String>,
  pub value: Option<OrderedFloat<f64>>,
}

impl TileUpdate {
  pub fn new<F1, F2>(id: F1, value: F2) -> TileUpdate where F1: Into<Option<String>>, F2: Into<Option<OrderedFloat<f64>>> {
    TileUpdate {
      id: id.into(),
      value: value.into(),
    }
  }
}

impl TSerializable for TileUpdate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TileUpdate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TileUpdate {
      id: f_1,
      value: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TileUpdate");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SeriesUpdate
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SeriesUpdate {
  pub id: Option<String>,
  pub points: Option<Vec<SDPoint>>,
}

impl SeriesUpdate {
  pub fn new<F1, F2>(id: F1, points: F2) -> SeriesUpdate where F1: Into<Option<String>>, F2: Into<Option<Vec<SDPoint>>> {
    SeriesUpdate {
      id: id.into(),
      points: points.into(),
    }
  }
}

impl TSerializable for SeriesUpdate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SeriesUpdate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<SDPoint>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDPoint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = SDPoint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SeriesUpdate {
      id: f_1,
      points: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SeriesUpdate");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.points {
      o_prot.write_field_begin(&TFieldIdentifier::new("points", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChartUpdate
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChartUpdate {
  pub id: Option<String>,
  pub series: Option<Vec<SeriesUpdate>>,
}

impl ChartUpdate {
  pub fn new<F1, F2>(id: F1, series: F2) -> ChartUpdate where F1: Into<Option<String>>, F2: Into<Option<Vec<SeriesUpdate>>> {
    ChartUpdate {
      id: id.into(),
      series: series.into(),
    }
  }
}

impl TSerializable for ChartUpdate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChartUpdate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<SeriesUpdate>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SeriesUpdate> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = SeriesUpdate::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChartUpdate {
      id: f_1,
      series: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChartUpdate");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.series {
      o_prot.write_field_begin(&TFieldIdentifier::new("series", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CompletionEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompletionEvent {
  pub total_widgets: Option<i32>,
  pub duration_ms: Option<i64>,
}

impl CompletionEvent {
  pub fn new<F1, F2>(total_widgets: F1, duration_ms: F2) -> CompletionEvent where F1: Into<Option<i32>>, F2: Into<Option<i64>> {
    CompletionEvent {
      total_widgets: total_widgets.into(),
      duration_ms: duration_ms.into(),
    }
  }
}

impl TSerializable for CompletionEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompletionEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CompletionEvent {
      total_widgets: f_1,
      duration_ms: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompletionEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.total_widgets {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalWidgets", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.duration_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("durationMs", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StreamMessage
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StreamMessage {
  pub type_: Option<StreamMessageType>,
  pub skeleton: Option<DashboardSkeleton>,
  pub tile_update: Option<TileUpdate>,
  pub chart_update: Option<ChartUpdate>,
  pub complete: Option<CompletionEvent>,
}

impl StreamMessage {
  pub fn new<F1, F2, F3, F4, F5>(type_: F1, skeleton: F2, tile_update: F3, chart_update: F4, complete: F5) -> StreamMessage where F1: Into<Option<StreamMessageType>>, F2: Into<Option<DashboardSkeleton>>, F3: Into<Option<TileUpdate>>, F4: Into<Option<ChartUpdate>>, F5: Into<Option<CompletionEvent>> {
    StreamMessage {
      type_: type_.into(),
      skeleton: skeleton.into(),
      tile_update: tile_update.into(),
      chart_update: chart_update.into(),
      complete: complete.into(),
    }
  }
}

impl TSerializable for StreamMessage {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StreamMessage> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StreamMessageType> = None;
    let mut f_2: Option<DashboardSkeleton> = None;
    let mut f_3: Option<TileUpdate> = None;
    let mut f_4: Option<ChartUpdate> = None;
    let mut f_5: Option<CompletionEvent> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StreamMessageType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = DashboardSkeleton::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TileUpdate::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = ChartUpdate::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = CompletionEvent::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StreamMessage {
      type_: f_1,
      skeleton: f_2,
      tile_update: f_3,
      chart_update: f_4,
      complete: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StreamMessage");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.skeleton {
      o_prot.write_field_begin(&TFieldIdentifier::new("skeleton", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tile_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("tileUpdate", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.chart_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("chartUpdate", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.complete {
      o_prot.write_field_begin(&TFieldIdentifier::new("complete", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TelemetryService service client
//

pub trait TTelemetryServiceSyncClient {
  fn aquariums(&mut self) -> thrift::Result<Vec<SDAquarium>>;
  fn dashboard(&mut self, aquarium_id: String, hours: i32) -> thrift::Result<SDPage>;
}

pub trait TTelemetryServiceSyncClientMarker {}

pub struct TelemetryServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> TelemetryServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> TelemetryServiceSyncClient<IP, OP> {
    TelemetryServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for TelemetryServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TTelemetryServiceSyncClientMarker for TelemetryServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TTelemetryServiceSyncClientMarker> TTelemetryServiceSyncClient for C {
  fn aquariums(&mut self) -> thrift::Result<Vec<SDAquarium>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Aquariums", TMessageType::Call, self.sequence_number());
        let call_args = TelemetryServiceAquariumsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Aquariums", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TelemetryServiceAquariumsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn dashboard(&mut self, aquarium_id: String, hours: i32) -> thrift::Result<SDPage> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Dashboard", TMessageType::Call, self.sequence_number());
        let call_args = TelemetryServiceDashboardArgs { aquarium_id, hours };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TelemetryServiceDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// TelemetryService service processor
//

pub trait TelemetryServiceSyncHandler {
  fn handle_aquariums(&self) -> thrift::Result<Vec<SDAquarium>>;
  fn handle_dashboard(&self, aquarium_id: String, hours: i32) -> thrift::Result<SDPage>;
}

pub struct TelemetryServiceSyncProcessor<H: TelemetryServiceSyncHandler> {
  handler: H,
}

impl <H: TelemetryServiceSyncHandler> TelemetryServiceSyncProcessor<H> {
  pub fn new(handler: H) -> TelemetryServiceSyncProcessor<H> {
    TelemetryServiceSyncProcessor {
      handler,
    }
  }
  fn process_aquariums(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTelemetryServiceProcessFunctions::process_aquariums(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTelemetryServiceProcessFunctions::process_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TTelemetryServiceProcessFunctions;

impl TTelemetryServiceProcessFunctions {
  pub fn process_aquariums<H: TelemetryServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TelemetryServiceAquariumsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_aquariums() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Aquariums", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TelemetryServiceAquariumsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Aquariums", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("Aquariums", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_dashboard<H: TelemetryServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TelemetryServiceDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_dashboard(args.aquarium_id, args.hours) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TelemetryServiceDashboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("Dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: TelemetryServiceSyncHandler> TProcessor for TelemetryServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "Aquariums" => {
        self.process_aquariums(message_ident.sequence_number, i_prot, o_prot)
      },
      "Dashboard" => {
        self.process_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// TelemetryServiceAquariumsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TelemetryServiceAquariumsArgs {
}

impl TelemetryServiceAquariumsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TelemetryServiceAquariumsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TelemetryServiceAquariumsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Aquariums_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TelemetryServiceAquariumsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TelemetryServiceAquariumsResult {
  result_value: Option<Vec<SDAquarium>>,
}

impl TelemetryServiceAquariumsResult {
  fn ok_or(self) -> thrift::Result<Vec<SDAquarium>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TelemetryServiceAquariums"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TelemetryServiceAquariumsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<SDAquarium>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SDAquarium> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = SDAquarium::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TelemetryServiceAquariumsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TelemetryServiceAquariumsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TelemetryServiceDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TelemetryServiceDashboardArgs {
  aquarium_id: String,
  hours: i32,
}

impl TelemetryServiceDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TelemetryServiceDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TelemetryServiceDashboardArgs.aquarium_id", &f_1)?;
    verify_required_field_exists("TelemetryServiceDashboardArgs.hours", &f_2)?;
    let ret = TelemetryServiceDashboardArgs {
      aquarium_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      hours: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("aquarium_id", TType::String, 1))?;
    o_prot.write_string(&self.aquarium_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hours", TType::I32, 2))?;
    o_prot.write_i32(self.hours)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TelemetryServiceDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TelemetryServiceDashboardResult {
  result_value: Option<SDPage>,
}

impl TelemetryServiceDashboardResult {
  fn ok_or(self) -> thrift::Result<SDPage> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TelemetryServiceDashboard"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TelemetryServiceDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SDPage> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SDPage::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TelemetryServiceDashboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TelemetryServiceDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

